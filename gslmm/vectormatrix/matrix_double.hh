//
// $Id: matrix_skel.hh,v 1.22 2007-04-21 09:03:14 cholm Exp $ 
//  
// WARNING: automatically generated by make-header.sh
//          options: @skel@, double .  
//          Do not edit this file.
//
//  gslmm::matrix_double
//  Copyright (C) 2002 Christian Holm Christensen <cholm@nbi.dk> 
//
//  This library is free software; you can redistribute it and/or 
//  modify it under the terms of the GNU Lesser General Public License 
//  as published by the Free Software Foundation; either version 2.1 
//  of the License, or (at your option) any later version. 
//
//  This library is distributed in the hope that it will be useful, 
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
//  Lesser General Public License for more details. 
// 
//  You should have received a copy of the GNU Lesser General Public 
//  License along with this library; if not, write to the Free 
//  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
//  02111-1307 USA 
//
#ifndef GSLMM_matrix_double
#define GSLMM_matrix_double
#line 29 "matrix_skel.hh"
/** @file   matrix_double.hh
    @author Christian Holm
    @date   Mon Mar 10 14:50:12 2003
    @brief  @c double  specialisation of matrix class */

#ifndef GSLMM_matrix_base
# include <gslmm/vectormatrix/matrix_base.hh>
#endif
#ifndef _GSL_MATRIX_H_
# include <gsl/gsl_matrix.h>
#endif
#ifndef GSLMM_vectormatrix_vector_double
# include <gslmm/vectormatrix/vector_double.hh>
#endif
#if 0
# ifndef GSLMM_
#  include <gslmm/compleks/.hh>
# endif
#endif
#ifndef GSLMM_math_type_trait
# include <gslmm/math/type_trait.hh>
#endif

namespace gslmm
{
  /** @brief Matrix @c double  specialisation.
      @ingroup matrix
   */
  template <>
  class matrix<double >
  {
  public:
    /** Size type. */
    typedef size_t size_type;
    /** Iterator (or indexer) type. */
    typedef size_t iterator;
    /** Type of data */
    typedef double  value_type;
    /** Type of data */
    typedef double element_type;
    /** Low level data type */
    typedef gsl_matrix data_type;
    /** Low level view type */
    typedef gsl_matrix_view view_type;
    /** Type of associated vectors */
    typedef vector<value_type> vector_type;
    /** Type of traits for elements */
    typedef type_trait<value_type> trait_type;
    /** Type of reference */
    typedef trait_type::reference_type reference_type;
    /** Type of return value */
    typedef matrix_return<value_type> return_type;
    /** Type of passed return type */
    typedef std::auto_ptr<return_type> oper_type;

    /** Constructor from a product 
	@param p Product */
    matrix(oper_type p);
    /** Constructor. 
	@param rows Number of rows in matrix. 
	@param columns Number of columns in matrix. 
	@param zero If true initialise to zero (null) matrix. */
    matrix(size_t rows, size_t columns, bool zero=true);
#if 0
    /** Copy constructor. 
	@param m The matrix to copy. 
	@param trans If true, the transpose of @a m is copied to this
	object.
	@param conj If true, also conjugate the matrix. */
    matrix(const matrix<value_type>& m, bool trans=false, bool conj=false);
#else
    /** Copy constructor. 
	@param m The matrix to copy. 
	@param trans If true, the transpose of @a m is copied to 
	@c this. */
    matrix(const matrix<value_type>& m, bool trans=false);
#endif
    /** View constructor.
	@param m Matrix to create view from,
	@param row_offset Offset in row direction, 
	@param column_offset Offset in column direction,
	@param rows Rows in view
	@param columns Columns in view. 
	@param tda If positive, the physical number of columns in
	memory. */
    matrix(const matrix<value_type>& m, 
	   iterator row_offset, iterator column_offset, 
	   size_type rows, size_type columns, size_type tda=0);
    /** View constructor.
	@param array Array to create view from,
	@param rows Rows in view
	@param columns Columns in view. 
	@param tda If positive, the physical number of columns in
	memory. */
    matrix(element_type* array, size_type rows, size_type columns, 
	   size_type tda=0);
    /** View constructor.
	@param v Vector to create view from,
	@param rows Rows in view
	@param columns Columns in view. 
	@param tda If positive, the physical number of columns in
	memory. */
    matrix(const vector_type& v, 
	   size_type rows, size_type columns, size_type tda=0);
    /** Destructor.  */
    virtual ~matrix();

    /** @{
	@name Swaping data */
    /** Swap two matricies. */
    void swap(const matrix<value_type>& m);
    /** Swap two rows .*/
    void swap_rows(iterator i, iterator j);
    /** Swap two columns .*/
    void swap_columns(iterator i, iterator j);
    /** Swap row @a i for column @a j. Matrix must be square. */
    void swap_row_column(iterator i, iterator j);
    /** @} */
    

    /** @{
	@name Information */
    /** Get the number of rows. */
    size_type row_size() const { return _matrix->size1; }
    /** Get the number of columns. */
    size_type column_size() const { return _matrix->size2; }
    /** Whether this is the owner of the data. */
    bool is_owner() const; 
    /** Whether this is the null matrix. */
    bool is_null() const;
    /** Get the physical number of columns in memory. */
    size_type tda() const { return _matrix->tda; }
    /** @} */

    /** @{
	@name Manipulations */
    /** Reset all elements to zero */
    void zero();
    /** Set all elements to one number. 
	@param x the value to set all elements to. */
    void set(value_type x);
    /** Make an identity matrix.
       only the @f$ i,i@f$ elements are 1, the rest of the elements
       are zero.  */
    void identity();
    /** Make this into the transpose of it self.  This member function
	only works for square matricies. */
    void transpose();
#if 0
    /** Conjugate all elements of the matrix. */
    void conjugate();
#endif
    /** @} */

    /** @{ 
	@name Member access */
    /** Member accessor. 
	@param row The row number 
	@param column The column number 
	@return the @f$ i,j@f$-th element. */
    const reference_type operator()(iterator row, iterator column) const;
    /** Member accessor. 
	@param row The row number 
	@param column The column number 
	@return the @f$ i,j@f$-th element. */
    reference_type operator()(iterator row, iterator column);
    /** Get a row. 
	@param r The row number to get (starts at 0) 
	@return the @a r row of the matrix, as a reference only */
    vector_type operator[](iterator r);
    /** Get a row (const version).
	@param r The row number to get (starts at 0)
	@return the @a r row of the matrix, as a reference only */
    const vector_type operator[](iterator r) const;
    /** Get a pointer to the element at (@a row, @a col) 
	@param row Row number 
	@param column Column number 
	@return pointer to element (@a i, @a j) */
    value_type* element(iterator row, iterator column);
    /** Get a pointer to the element at (@a row, @a col) 
	@param row Row number 
	@param column Column number 
	@return pointer to element (@a i, @a j) */
    const value_type* element(iterator row, iterator column) const;
    /** @} */

    /** @{
	@name Views of all kinds */
    /** Get a sub-matrix of this matrix. 
	@param row Row in this matrix to start at 
	@param column Column in this matrix to start at 
	@param rows Number of rows in sub-matrix 
	@param columns Number of columns in sub-martix. 
	@return a new matrix object that does not own the data. */
    matrix<double > operator()(iterator row, iterator column, 
				    size_type rows, size_type columns) const;
    /** Get a row. 
	@param r The row number to get (starts at 0) 
	@return the @a r row of the matrix, as a reference only */
    vector_type row(iterator r);
    /** Get a row (const version).
	@param r The row number to get (starts at 0)
	@return the @a r row of the matrix, as a reference only */
    const vector_type row(iterator r) const;
    /** Get a column. 
	@param c The column number to get (starts at 0)
	@return the @a c column of the matrix, as a reference only */
    vector_type column(iterator c);
    /** Get a column (const version).
	@param c The column number to get (starts at 0)
	@return the @a c column of the matrix, as a reference only */
    const vector_type column(iterator c) const;
    /** Get the diagonal. 
	@param d The diagonal number.  Negative are below diagonal,
	positive above, and zero is the diagonal itself.
	@return the diagonal of the matrix, as a reference only */
    vector_type diagonal(int d);
    /** Get the diagonal (const version).
	@param d The diagonal number.  Negative are below diagonal,
	positive above, and zero is the diagonal itself.
	@return the diagonal of the matrix, as a reference only */
    const vector_type diagonal(int d) const;
    /** Get a sub-diagonal. 
	@param s The sub-diagonal number to get (0 is diagonal)
	@return the @a s sub-diagonal of the matrix, as a reference only */
    vector_type sub_diagonal(int s);
    /** Get a sub-diagonal (const version).
	@param s The sub-diagonal number to get (0 is the diagonal)
	@return the @a s sub-diagonal of the matrix, as a reference only */
    const vector_type sub_diagonal(int s) const;
    /** Get a super-diagonal. 
	@param s The super-diagonal number to get (0 is diagonal)
	@return the @a s super-diagonal of the matrix, as a reference only */
    vector_type super_diagonal(int s);
    /** Get a super-diagonal (const version).
	@param s The super-diagonal number to get (0 is the diagonal)
	@return the @a s super-diagonal of the matrix, as a reference only */
    const vector_type super_diagonal(int s) const;
    /** @} */

    /** @{
	@name Assignment operations */
    /** Assignment operator */
    matrix<value_type>& 
    operator=(const matrix<value_type>& m);
    /** Assignment operator */
    matrix<value_type>& 
    operator=(oper_type m);
    /** Add a matrix, element by element
	@param o The matrix to add to @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}+o_{ij}@f$ */
    matrix<value_type>& 
    operator+=(const matrix<value_type>& o);
    /** Subtract a matrix, element by element
	@param o The matrix to subtract from @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}-o_{ij}@f$ */
    matrix<value_type>& 
    operator-=(const matrix<value_type>& o);
    /** Multiply by a matrix, element by element
	@param o The matrix to multiply to @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}o_{ij}@f$ */
    matrix<value_type>& 
    operator*=(const matrix<value_type>& o);
    /** Divide by a matrix, element by element
	@param o The matrix to divide into @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}/o_{ij}@f$ */
    matrix<value_type>& 
    operator/=(const matrix<value_type>& o);
    /** Add a number to all elements
	@param o The number to add to @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}+o@f$ */
    matrix<value_type>& operator+=(const value_type& o);
    /** Subtract a number from all elements
	@param o The number to subtract from @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}-o@f$ */
    matrix<value_type>& operator-=(const value_type& o);
    /** Multiply all elements by a number.
	@param o The number to multiply to @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}o@f$ */
    matrix<value_type>& operator*=(const value_type& o);
    /** Divide all elements by a number
	@param o The number to divide into @c this 
	@return this matrix, where @f$ m'_{ij}= m_{ij}/o@f$ */
    matrix<value_type>& operator/=(const value_type& o);
    /** @} */

#if 0
#else
    /** @{ 
	@name Minimum and maximum elemens */
    /** Find the smallest value in matrix. 
	@return the smallest element in matrix. */
    value_type min() const;
    /** Find the largest value in matrix. 
	@return the largest element in matrix. */
    value_type max() const;
    /** Find the smallest and largest values in matrix.
	@param min Smallest element in matrix.
	@param max Largest element in matrix. */
    void minmax(value_type& min, value_type& max) const;
    /** Find the position of the smallest value in matrix. 
	@param row Row index of smallest element in matrix.
	@param column Column index of smallest element in matrix. */
    void min_index(iterator& row, iterator& column) const;
    /** Find the position of the largest value in matrix. 
	@param row Row index of largest element in matrix.
	@param column Column index of largest element in matrix. */
    void max_index(iterator& row, iterator& column) const;
    /** Find the positions of the smallest and largest values in matrix.
	@param min_row Rows index of the smallest element in matrix.
	@param min_column Column index of the smallest element in matrix. 
	@param max_row Rows index of the largest element in matrix.
	@param max_column Column index of the largest element in matrix. */
    void minmax_index(iterator& min_row, iterator& min_column,
		      iterator& max_row, iterator& max_column) const;
    /** @} */
#endif
    /** The data */
    data_type* _matrix;
  protected:
    /** Construct from a view */
    void from_view(view_type&  view);
    /** Constructor. */
    matrix() : _matrix(0) {}
  };
}

namespace gslmm
{
  //__________________________________________________________________
  inline matrix<double >::matrix(oper_type p) 
    : _matrix(0)
  {
    assert(p.get());
    if (!p.get()) GSL_ERROR_VOID("NULL return passed", GSL_EINVAL);
    _matrix = gsl_matrix_calloc(p->row_size(), p->column_size());
    p->operator()(*this);
    // delete p;
    // p = 0;
  }

  //__________________________________________________________________
  inline matrix<double >::matrix(size_t rows, size_t columns, bool zero) 
    : _matrix(0)
  {
    if (zero) _matrix = gsl_matrix_calloc(rows, columns);
    else      _matrix = gsl_matrix_alloc(rows, columns);
  }
  //__________________________________________________________________
  inline matrix<double >::matrix(const matrix<value_type>& m,
				bool trans
#if 0
				, bool conj
#endif
				) 
    : _matrix(0)
  {
    if (!trans) {
      _matrix = gsl_matrix_alloc(m.row_size(), m.column_size());
      *this = m;
    }
    else {
      _matrix = gsl_matrix_alloc(m.column_size(), m.row_size());
      gsl_matrix_transpose_memcpy(_matrix,m._matrix);
    }
#if 0
    if (conj) conjugate();
#endif
  }
  
  //__________________________________________________________________
  inline 
  matrix<double >::matrix(const matrix<value_type>& m, 
			 iterator row_offset, iterator column_offset, 
			 size_type rows, size_type columns, 
			 size_type) 
    : _matrix(0)
  {
    view_type v = gsl_matrix_submatrix(m._matrix,
					    row_offset, 
					    column_offset,
					    rows, columns);
    from_view(v);
  }
  //__________________________________________________________________
  inline matrix<double >::matrix(element_type* array, 
				size_type rows, size_type columns, 
				size_type tda) 
    : _matrix(0)
  {
    view_type v;
    if (tda <= 0)
      v = gsl_matrix_view_array(array, rows, columns);
    else 
      v = gsl_matrix_view_array_with_tda(array, rows, columns, tda);
    from_view(v);
  }
  //__________________________________________________________________
  inline 
  matrix<double >::matrix(const vector_type& vec,
			 size_type rows, size_type columns, 
			 size_type tda) 
     : _matrix(0)
 {
    view_type v;
    if (tda <= 0)
      v = gsl_matrix_view_vector(vec._vector, rows, columns);
    else 
      v = gsl_matrix_view_vector_with_tda(vec._vector, rows, 
							columns, tda);
    from_view(v);
  }
  
  //__________________________________________________________________
  inline matrix<double >::~matrix()
  {
    gsl_matrix_free(_matrix);
  }
  //__________________________________________________________________
  inline void matrix<double >::from_view(view_type& v)
  {
    _matrix = static_cast<data_type*>(malloc(sizeof(data_type)));
    _matrix->size1 = v.matrix.size1;
    _matrix->size2 = v.matrix.size2;
    _matrix->tda   = v.matrix.tda;
    _matrix->data  = v.matrix.data;
    _matrix->block = v.matrix.block;
    _matrix->owner = v.matrix.owner;
  }
  //__________________________________________________________________
  inline matrix<double >&
  matrix<double >::operator=(const matrix<value_type>& m)
  {
    gsl_matrix_memcpy(_matrix,m._matrix);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<double >&
  matrix<double >::operator=(oper_type p)
  {
    assert(p.get());
    if (!p.get()) GSL_ERROR_VAL("NULL return passed", GSL_EINVAL, *this);
    p->operator()(*this);
    return *this;
  }
  //__________________________________________________________________
  inline void
  matrix<double >::swap(const matrix<value_type>& m)
  {
    gsl_matrix_swap(_matrix,m._matrix);
  }
  //__________________________________________________________________
  inline void
  matrix<double >::swap_rows(iterator i, iterator j)
  {
    gsl_matrix_swap_rows(_matrix,i, j);
  }
  //__________________________________________________________________
  inline void
  matrix<double >::swap_columns(iterator i, iterator j)
  {
    gsl_matrix_swap_columns(_matrix,i, j);
  }
  //__________________________________________________________________
  inline void
  matrix<double >::swap_row_column(iterator i, iterator j)
  {
    gsl_matrix_swap_rowcol(_matrix,i, j);
  }
  //__________________________________________________________________
  inline bool
  matrix<double >::is_owner()  const
  {
    return _matrix->owner == 1;
  }
  //__________________________________________________________________
  inline bool
  matrix<double >::is_null()  const 
  {
    return gsl_matrix_isnull(_matrix) == 1;
  }
  //__________________________________________________________________
  inline void
  matrix<double >::zero() 
  {
    gsl_matrix_set_zero(_matrix);
  }
  //__________________________________________________________________
  inline void
  matrix<double >::set(value_type x) 
  {
    gsl_matrix_set_all(_matrix, x);
  }
  //__________________________________________________________________
  inline void
  matrix<double >::identity()
  {
    gsl_matrix_set_identity(_matrix);
  }
  //__________________________________________________________________
  inline void
  matrix<double >::transpose()
  {
    gsl_matrix_transpose(_matrix);
  }
  //__________________________________________________________________
  inline matrix<double >
  matrix<double >::operator()(iterator i, iterator j, size_type n1, 
				   size_type n2) const
  {
    return matrix<double >(*this, i, j, n1, n2);
  }
  //__________________________________________________________________
  inline 
  const matrix<double >::reference_type
  matrix<double >::operator()(iterator i, iterator j) const 
  {
#if 0
    return reference_type(gsl_matrix_ptr(_matrix, i, j));
#else 
    return reference_type(*(gsl_matrix_ptr(_matrix, i, j)));
#endif
  }
  //__________________________________________________________________
  inline 
  matrix<double >::reference_type
  matrix<double >::operator()(iterator i, iterator j) 
  {
#if 0
    return reference_type(gsl_matrix_ptr(_matrix, i, j));
#else 
    return reference_type(*(gsl_matrix_ptr(_matrix, i, j)));
#endif
  }
  //__________________________________________________________________
  inline matrix<double >::vector_type
  matrix<double >::operator[](iterator i)
  {
    // Must be implemented here - temporary
    return vector_type(gsl_matrix_row(_matrix,i));
  }
  //__________________________________________________________________
  inline const matrix<double >::vector_type
  matrix<double >::operator[](iterator i) const
  {
    // Must be implemented here - temporary
    return vector_type(gsl_matrix_row(_matrix,i));
  }
  //__________________________________________________________________
  inline matrix<double >::value_type*
  matrix<double >::element(iterator row, iterator column) 
  {
    // Must be implemented here - temporary
    
    return (value_type*)(gsl_matrix_ptr(_matrix,row, column));
  }
  //__________________________________________________________________
  inline const matrix<double >::value_type*
  matrix<double >::element(iterator row, iterator column) const
  {
    // Must be implemented here - temporary
    return (value_type*)(gsl_matrix_const_ptr(_matrix,row, column));
  }
  //__________________________________________________________________
  inline matrix<double >::vector_type
  matrix<double >::row(iterator i)
  {
    return vector_type(gsl_matrix_row(_matrix,i));
  }
  //__________________________________________________________________
  inline const matrix<double >::vector_type
  matrix<double >::row(iterator i) const
  {
    return vector_type(gsl_matrix_row(_matrix,i));
  }
  //__________________________________________________________________
  inline matrix<double >::vector_type
  matrix<double >::column(iterator i)
  {
    return vector_type(gsl_matrix_column(_matrix,i));
  }
  //__________________________________________________________________
  inline const matrix<double >::vector_type
  matrix<double >::column(iterator i) const
  {
    return vector_type(gsl_matrix_column(_matrix,i));
  }
  //__________________________________________________________________
  inline matrix<double >::vector_type
  matrix<double >::diagonal(int i)
  {
    if (i == 0)     
      return vector_type(gsl_matrix_diagonal(_matrix));
    else if (i < 0) 
      return 
	vector_type(gsl_matrix_subdiagonal(_matrix,-i));
    return 
      vector_type(gsl_matrix_superdiagonal(_matrix,i));
  }
  //__________________________________________________________________
  inline const matrix<double >::vector_type
  matrix<double >::diagonal(int i) const
  {
    if (i == 0)     
      return vector_type(gsl_matrix_diagonal(_matrix));
    else if (i < 0) 
      return 
	vector_type(gsl_matrix_subdiagonal(_matrix,-i));
    return 
      vector_type(gsl_matrix_superdiagonal(_matrix,i));
  }
  //__________________________________________________________________
  inline matrix<double >::vector_type
  matrix<double >::sub_diagonal(int i)
  {
    return diagonal(-i);
  }
  //__________________________________________________________________
  inline const matrix<double >::vector_type
  matrix<double >::sub_diagonal(int i) const
  {
    return diagonal(-i);
  }
  //__________________________________________________________________
  inline matrix<double >::vector_type
  matrix<double >::super_diagonal(int i)
  {
    return diagonal(i);
  }
  //__________________________________________________________________
  inline const matrix<double >::vector_type
  matrix<double >::super_diagonal(int i) const
  {
    return diagonal(i);
  }
  //__________________________________________________________________
  inline matrix<double >&
  matrix<double >::operator*=(const matrix<value_type>& m)
  {
    gsl_matrix_mul_elements(_matrix,m._matrix);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<double >&
  matrix<double >::operator/=(const matrix<value_type>& m)
  {
    gsl_matrix_div_elements(_matrix,m._matrix);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<double >&
  matrix<double >::operator+=(const matrix<value_type>& m)
  {
    gsl_matrix_add(_matrix,m._matrix);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<double >&
  matrix<double >::operator-=(const matrix<value_type>& m)
  {
    gsl_matrix_sub(_matrix,m._matrix);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<double >&
  matrix<double >::operator+=(const value_type& x)
  {
    gsl_matrix_add_constant(_matrix,x);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<double >&
  matrix<double >::operator-=(const value_type& x)
  {
    gsl_matrix_add_constant(_matrix,-x);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<double >&
  matrix<double >::operator*=(const value_type& x)
  {
    gsl_matrix_scale(_matrix,x);
    return *this;
  }
  //__________________________________________________________________
  inline matrix<double >&
  matrix<double >::operator/=(const value_type& x)
  {
    gsl_matrix_scale(_matrix,x);
    return *this;
  }  
#if 0
  //__________________________________________________________________
  inline 
  void
  matrix<double >::conjugate() 
  {
    for (size_t row = 0; row < row_size(); row++) {
      for (size_t col = 0; col < column_size(); col++) {
	value_type c  = operator()(row,col);
	value_type cc(c.conjugate());
	operator()(row,col) = cc;
      }
    }
  }
#else
  //__________________________________________________________________
  inline 
  matrix<double >::value_type
  matrix<double >::min() const 
  {
    return gsl_matrix_min(_matrix);
  }
  //__________________________________________________________________
  inline 
  matrix<double >::value_type
  matrix<double >::max() const 
  {
    return gsl_matrix_max(_matrix);
  }
  //__________________________________________________________________
  inline void
  matrix<double >::minmax(value_type& min, value_type& max) const 
  {
    return gsl_matrix_minmax(_matrix, &min, &max);
  }
  //__________________________________________________________________
  inline void
  matrix<double >::min_index(iterator& row, iterator& column) const 
  {
    gsl_matrix_min_index(_matrix, &row, &column);
  }
  //__________________________________________________________________
  inline void
  matrix<double >::max_index(iterator& row, iterator& column) const 
  {
    gsl_matrix_max_index(_matrix, &row, &column);
  }
  //__________________________________________________________________
  inline void
  matrix<double >::minmax_index(iterator& min_row, iterator& min_column,
			       iterator& max_row, iterator& max_column) 
    const 
  {
    gsl_matrix_minmax_index(_matrix, &min_row, &min_column,
					  &max_row, &max_column);
  }
#endif
}


#endif
//____________________________________________________________________
//
// EOF
//
